package problem0096

// 不同的二叉搜索树, 对于[1, ...n], 遍历每个数字i，将该数作为树的树根，将i左侧作为左子树，i右侧作为右子树
// 步骤一: 定义数组元素的含义 => dp[i]代表长度为i的序列的不同二叉搜索树的个数
// 步骤二: 数组元素之间的关系 => dp[n] = dp[0]*dp[n-1] + dp[1]*dp[n-2] .... + dp[n-1]*dp[0]
// 别人的结题思路：
// 		假设n个节点存在二叉排序树的个数是G(n)，1为根节点，2为根节点，...，n为根节点，
// 		当1为根节点时，其左子树节点个数为0，右子树节点个数为n-1，
// 		当2为根节点时，其左子树节点个数为1，右子树节点为n-2，
// 		所以可得G(n) = G(0)*G(n-1)+G(1)*(n-2)+...+G(n-1)*G(0)
// 步骤三: 找出初始值 => 空树dp[0] = 1，只有根dp[1] = 1
func numTrees(n int) int {
	dp := make([]int, n+1)
	dp[0] = 1
	dp[1] = 1
	// 需要填充dp数组, 索引从2开始
	for i := 2; i < n+1; i++ {
		// 为dp[i]开始累加, 范围从0到i-1, 对应dp[j]的另一因子为dp[i-1-j]
		for j := 0; j < i; j++ {
			dp[i] += dp[j] * dp[i-1-j]
		}
	}
	return dp[n]
}
