## LeetCode栈30题速刷指南

相关连接：

[栈 - leetcode](https://leetcode-cn.com/tag/stack/)

在栈专题中过滤掉面试题系列（因为不是数字标题）以及会员系列（因为不是会员）以及"链表概念题"（因为不追概念），下文将对以下的题目（共30题）进行分析总结：

### 类型一：单调递增/减栈

> 单调栈是指栈内元素（栈底到栈顶）都是单调递增或者单调递减的，核心性质：**递增（减）栈中可以找到元素左右两侧比自身小（大）的第一个元素**

假设当前单增栈中元素为：`[1, 3, 4, 5]`, 当前元素为`2`：
+ 对于要出栈的元素`3、4、5`来说，它们右侧比自身小的第一个元素就是`2`
+ 对于要进栈的元素`2`来说，它左侧比自身小的第一个元素就是`1`

假设当前单减栈中元素为：`[5, 3, 2, 1]`, 当前元素为`4`:
+ 对于要出栈的元素`3、2、1`来说，它右侧比自身大的第一个元素就是`4`
+ 对于要进栈的元素`4`来说，它左侧比自身大的第一个元素就是`5`

单调栈实际就是栈，只是利用了一些巧妙的逻辑，使得每次新元素入栈之后，栈内元素都保持有序，**它的用途并不广泛，只能处理一种典型的问题：下一个更大（小）的数**

- [x] [496:下一个更大元素 I](#496题) - 单调栈
- [x] [503:下一个更大元素 II](#503题)
- [ ] [1019:链表中的下一个更大节点](#1019题)
- [ ] [739:每日温度](#739题)

## TODO

- [x] [20:有效的括号](#20题) - 基础的栈
- [ ] [42:接雨水](#42题)
- [ ] [71:简化路径](#71题)
- [ ] [84:柱状图中最大的矩形](#84题)
- [ ] [85:最大矩形](#85题)
- [ ] [150:逆波兰表达式求值](#150题)
- [ ] [155:最小栈](#155题) - 设计
- [ ] [225:用队列实现栈](#225题) - 设计
- [ ] [232:用栈实现队列](#232题) - 设计
- [ ] [224:基本计算器](#224题)
- [ ] [316:去除重复字母](#316题)
- [ ] [341:扁平化嵌套列表迭代器](#341题)
- [ ] [385:迷你语法分析器](#385题)
- [ ] [394:字符串解码](#394题)
- [ ] [402:移掉K位数字](#402题)
- [ ] [439:三元表达式解析器](#439题)
- [ ] [456:132模式](#456题)
- [ ] [591:标签验证器](#591题)
- [ ] [636:函数的独占时间](#636题)
- [ ] [682:棒球比赛](#682题)
- [ ] [726:原子的数量](#726题)
- [ ] [735:行星碰撞](#735题)
- [ ] [770:基本计算器 IV](#770题)
- [ ] [772:基本计算器 III](#772题)
- [ ] [844:比较含退格的字符串](#844题)
- [ ] [856:括号的分数](#856题)
- [ ] [880:索引处的解码字符串](#880题)
- [ ] [895:最大频率栈](#895题)
- [ ] [901:股票价格跨度](#901题)
- [ ] [907:子数组的最小值之和](#907题)
- [ ] [921:使括号有效的最少添加](#921题)
- [ ] [946:验证栈序列](#946题)
- [ ] [975:奇偶跳](#975题)
- [ ] [1003:检查替换后的词是否有效](#1003题)
- [ ] [1021:删除最外层的括号](#1021题)
- [ ] [1047:删除字符串中的所有相邻重复项](#1047题)
- [ ] [1063:有效子数组的数目](#1063题)
- [ ] [1124:表现良好的最长时间段](#1124题)

## 所有题目详解

### 20题

基础的栈使用

````golang
func isValid(s string) bool {
	pairs := map[byte]byte{
		')': '(',
		'}': '{',
		']': '[',
	}
	stack := make([]byte, 0)

	for i := 0; i < len(s); i++ {
		if s[i] == '(' || s[i] == '{' || s[i] == '[' {
			stack = append(stack, s[i])
		} else if len(stack) > 0 && stack[len(stack)-1] == pairs[s[i]] {
			stack = stack[:len(stack)-1]
		} else {
			return false
		}
	}
	return len(stack) == 0
}
````

### 496题

单调栈的使用

````golang
func nextGreaterElement(nums1 []int, nums2 []int) []int {
	pairs := make(map[int]int, 0)
	stack := make([]int, 0)
	result := make([]int, len(nums1))
	// 构建单减栈
	for _, num := range nums2 {
		// 所有比num小的栈元素都出栈
		for len(stack) > 0 && num > stack[len(stack)-1] {
			pairs[stack[len(stack)-1]] = num
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, num)
	}
	for i, num := range nums1 {
		if v, ok := pairs[num]; ok {
			result[i] = v
		} else {
			result[i] = -1
		}
	}
	return result
}
````

### 503题

单调栈的使用

````golang
func nextGreaterElements(nums []int) []int {
	length := len(nums)
	stack := make([]int, 0)
	result := make([]int, length)
	for i := 0; i < length; i++ {
		result[i] = -1
	}
	// 要求循环就2倍长度取余即可
	for i := 0; i < length*2; i++ {
		// stack存储索引
		for len(stack) > 0 && nums[i%length] >= nums[stack[len(stack)-1]] {
			result[stack[len(stack)-1]] = nums[i%length]
			stack = stack[:len(stack)-1]
		}
		stack = append(stack, i%length)
	}
	return result
}
````