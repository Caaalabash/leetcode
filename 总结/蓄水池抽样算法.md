## 蓄水池抽样算法

leetcode相关题目：

+ [随机数索引](https://leetcode-cn.com/problems/random-pick-index/)
+ [链表随机节点](https://leetcode-cn.com/problems/linked-list-random-node/)

参考

[https://www.jianshu.com/p/7a9ea6ece2af](https://www.jianshu.com/p/7a9ea6ece2af)

[http://sofasofa.io/forum_main_post.php?postid=1002998](http://sofasofa.io/forum_main_post.php?postid=1002998)

### 引子

抽样问题最重要的是做到公平，也就是保证每个元素被抽到的概率是相同的。

对于知道数据规模的抽样问题来说，最容易的解决办法就是生成随机数，例如从1000人中抽取10人的问题，可以通过算法生成`[0, 999]`间的10个随机数，取出即可。

对于不知道数据规模的抽样问题会如何呢？

> 给定一个数据流，数据流长度N很大，且N直到处理完所有数据之前都不可知，请问如何在只遍历一遍数据（O(N)）的情况下，能够随机选取出m个不重复的数据。

该场景包含了三个条件

+ 数据流长度 N 很大 => 不能放进内存
+ 只遍历一次 => 不能先遍历一遍预处理，只能边遍历边处理
+ 随机选取出m个不重复的数据 => 每个数据被选取的概率为 m/N

这就需要蓄水池算法了

### 算法过程

假设数据序列的规模为 N，需要抽取的样本为 m

1. 首先构建一个容量为 m 的蓄水池，将序列的前 m 个元素放入蓄水池
2. 对于之后的元素，假设该元素为第 i 个(i >= m)，**使其有** m/i 的概率能取代蓄水池中一个元素
3. 在遍历完数据序列后，蓄水池中剩下的元素即为要抽取的样本

### 算法证明

用数学归纳法证明：每个样本被选中的概率都是相等的。

三步走：

+ 初始情况，当前只有 m 个数据，那么每个样本都会进入蓄水池，概率为 m / m = 1，条件成立。
+ 当有 N 个数据，假设每个数据被选入蓄水池的概率相等，都是 m / N
+ 证明如果有 N+1 个数据时，每个数据进入池子的概率都是 m / (N+1)

对于第 n+1 个样本 X，它进入池子的概率显然是 m / (N+1)，因此这是算法设定的。

对于池子中某个元素 Y，它前一轮在池子中的概率为 m / N，下一轮它留在池子的概率P = (X没有被选中的概率 + X被选中但是Y没有被替换的概率) * 它前一轮在池子中的概率

````
// X没有被选中的概率为
1 - m / (N+1) = (N+1-m) / (N+1)

// X被选中但是Y没有被替换的概率为
m/(N+1) * (m-1)/m = (m-1) / (N+1)

// 以上两者和为
N / (N+1)

// 最终结果为
(m / N) * (N / (N+1)) = m / (N+1)
````

得证

### 算法实现

````
int[] reservoir = new int[m];

// init
for (int i = 0; i < reservoir.length; i++)
{
    reservoir[i] = dataStream[i];
}

for (int i = m; i < dataStream.length; i++)
{
    // 随机获得一个[0, i]内的随机整数
    int d = rand.nextInt(i + 1);
    // 如果随机整数落在[0, m-1]范围内，则替换蓄水池中的元素
    if (d < m)
    {
        reservoir[d] = dataStream[i];
    }
}
````



